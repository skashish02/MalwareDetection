from tkinter import *
import tkinter
import tkinter as tk
from tkinter import filedialog
from tkinter.filedialog import askopenfilename
from tkinter import simpledialog
import warnings
warnings.filterwarnings('ignore')
import pandas as pd     
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import LabelEncoder
from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split

from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
from sklearn.metrics import accuracy_score,confusion_matrix,classification_report
from sklearn.metrics import roc_curve
from sklearn.metrics import roc_auc_score

from sklearn.tree import DecisionTreeClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier

import os
import pickle

from keras.callbacks import ModelCheckpoint

from keras.preprocessing.sequence import pad_sequences
from keras.utils import to_categorical

from tensorflow.keras.models import Sequential,load_model
from tensorflow.keras.layers import Conv1D, MaxPooling1D, Flatten, Dense, Dropout, Activation, Convolution2D, Embedding, GRU, SimpleRNN
from tensorflow.keras.optimizers import Adam
from keras.preprocessing.text import Tokenizer

main = tkinter.Tk()
main.title("An Innovative and Intelligent Malware Prediction with Classification for Industrial IoT Systems") 
main.geometry("1600x1300")

global filename
global x_train, x_test, y_train, y_test
global X, Y
global le
global dataset
accuracy = []
precision = []
recall = []
fscore = []
global classifier
global cnn_model

def uploadDataset():
    global filename
    global dataset
    filename = filedialog.askopenfilename(initialdir = "Dataset")
    text.delete('1.0', END)
    text.insert(END,filename+' Loaded\n')
    dataset = pd.read_csv(filename)
    dataset.replace('?', np.nan, inplace=True)
    #dataset.replace('?', pd.NA, inplace=True)
    dataset.dropna(inplace=True)
    text.insert(END,str(dataset.head())+"\n\n")

def preprocessDataset():
    global X, y
    global le
    #global dataset
    global x_train, x_test, y_train, y_test
    le = LabelEncoder()
    text.delete('1.0', END)
    dataset.fillna(0, inplace = True)
    print(dataset.info())
    text.insert(END,str(dataset.head())+"\n\n")
    
    dataset.head()
    
    # Create a count plot
    sns.set(style="darkgrid")  # Set the style of the plot
    plt.figure(figsize=(8, 6))  # Set the figure size
    # Replace 'dataset' with your actual DataFrame and 'Drug' with the column name
    ax = sns.countplot(x='class', data=dataset, palette="Set3")
    plt.title("Count Plot")  # Add a title to the plot
    plt.xlabel("Class Categories")  # Add label to x-axis
    plt.ylabel("Count")  # Add label to y-axis
    # Annotate each bar with its count value
    for p in ax.patches:
        ax.annotate(f'{p.get_height()}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', fontsize=10, color='black', xytext=(0, 5),
                textcoords='offset points')

    plt.show()  # Display the plot
    # Encode categorical variables (Protocol and Anomaly) using LabelEncoder
    dataset['class'] = le.fit_transform(dataset['class'])
    print(dataset)
    # Split the dataset into features (X) and target variable (y)
    X = dataset.drop(['class'], axis=1)
    y = dataset['class']
    text.insert(END,"Total records found in dataset: "+str(X.shape[0])+"\n\n")
    x_train, x_test, y_train, y_test = train_test_split(X,y, test_size=0.2, random_state=0)
    text.insert(END,"Total records found in dataset to train: "+str(x_train.shape[0])+"\n\n")
    text.insert(END,"Total records found in dataset to test: "+str(x_test.shape[0])+"\n\n")
    print(x_train)

def rocGraph(testY, predict, algorithm):
    random_probs = [0 for i in range(len(testY))]
    p_fpr, p_tpr, _ = roc_curve(testY, random_probs, pos_label=1)
    plt.plot(p_fpr, p_tpr, linestyle='--', color='orange',label="True classes")
    ns_fpr, ns_tpr, _ = roc_curve(testY, predict,pos_label=1)
    plt.plot(ns_fpr, ns_tpr, linestyle='--', label='Predicted Classes')
    plt.title(algorithm+" ROC Graph")
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive rate')
    plt.show()   

def decisiontreeclassifier():
    global x_train, x_test, y_train, y_test, dt_classifier
    text.delete('1.0', END)
    # Create a Decision Tree classifier
    dt_classifier = DecisionTreeClassifier(max_depth=2)
    
    # Train the Decision Tree model
    dt_classifier.fit(x_train, y_train)
    
    # Make predictions on the test set
    predictions = dt_classifier.predict(x_test)
    
    p1 = precision_score(y_test, predictions, average='macro', zero_division=0) * 100
    r1 = recall_score(y_test,predictions, average='macro', zero_division=0) * 100
    f1 = f1_score(y_test,predictions, average='macro', zero_division=0) * 100
    a1 = accuracy_score(y_test,predictions) * 100
    accuracy.append(a1)
    precision.append(p1)
    recall.append(r1)
    fscore.append(f1)
    # Display precision, recall, F1-score, and accuracy in the Text widget
    text.insert(END, "DecisionTree Precision: " + str(p1) + "\n")
    text.insert(END, "DecisionTree Recall: " + str(r1) + "\n")
    text.insert(END, "DecisionTree FMeasure: " + str(f1) + "\n")
    text.insert(END, "DecisionTree Accuracy: " + str(a1) + "\n\n")
    
    # Compute confusion matrix
    cm = confusion_matrix(y_test, predictions)
    
    # Compute classification report
    report = classification_report(y_test, predictions)
    
    # Display confusion matrix in the Text widget
    text.insert(END, "Confusion Matrix:\n")
    text.insert(END, str(cm) + "\n\n")
    
    # Display classification report in the Text widget
    text.insert(END, "Classification Report:\n")
    text.insert(END, report)
    rocGraph(y_test, predictions, "DTC")
    plt.figure(figsize=(8, 6))
    sns.set(font_scale=1.2)  # Adjust font size for better visualization
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Anomaly Detected', 'NO Anomaly Detected'], yticklabels=['Anomaly Detected', 'NO Anomaly Detected'])
    plt.xlabel('Predicted label')
    plt.ylabel('True label')
    plt.title('Decision Tree Classifier Confusion Matrix')
    plt.show()
   

def Randomforestclassifier():
    global x_train, x_test, y_train, y_test
    global rf
    text.delete('1.0', END)
    rf=RandomForestClassifier(max_depth=2)
    rf.fit(x_train, y_train)
     
    
    predict = rf.predict(x_test)
    
    p2 = precision_score(y_test, predict, average='macro', zero_division=0) * 100
    r2 = recall_score(y_test, predict, average='macro', zero_division=0) * 100
    f2 = f1_score(y_test, predict, average='macro', zero_division=0) * 100
    a2 = accuracy_score(y_test, predict) * 100
    accuracy.append(a2)
    precision.append(p2)
    recall.append(r2)
    fscore.append(f2)
    # Display precision, recall, F1-score, and accuracy in the Text widget
    text.insert(END, "RF Precision: " + str(p2) + "\n")
    text.insert(END, "RF Recall: " + str(r2) + "\n")
    text.insert(END, "RF FMeasure: " + str(f2) + "\n")
    text.insert(END, "RF Accuracy: " + str(a2) + "\n\n")
    
    # Compute confusion matrix
    cm = confusion_matrix(y_test, predict)
    
    # Compute classification report
    report = classification_report(y_test, predict)
    
    # Display confusion matrix in the Text widget
    text.insert(END, "Confusion Matrix:\n")
    text.insert(END, str(cm) + "\n\n")
    
    # Display classification report in the Text widget
    text.insert(END, "Classification Report:\n")
    text.insert(END, report)
    rocGraph(y_test, predict, "RFC")
    plt.figure(figsize=(8, 6))
    sns.set(font_scale=1.2)  # Adjust font size for better visualization
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Anomaly Detected', 'NO Anomaly Detected'], yticklabels=['Anomaly Detected', 'NO Anomaly Detected'])
    plt.xlabel('Predicted label')
    plt.ylabel('True label')
    plt.title('Random Forest Classifier Confusion Matrix')
    plt.show()
    
def trainDNN():
    global x_train, y_train, x_test, y_test, dnn
    text.delete('1.0', END)
    print(y_train.shape)
    print(x_train.shape)
    # One-hot encode categorical labels
    y_train_encoded = to_categorical(y_train, num_classes=2)
    y_test_encoded = to_categorical(y_test, num_classes=2)

    dnn = Sequential()
    dnn.add(Dense(units=128, input_shape=(x_train.shape[1],), activation='selu'))
    dnn.add(Dropout(0.5))  # Add dropout for regularization
    dnn.add(Dense(units=64, activation='relu'))
    dnn.add(Dropout(0.5))
    dnn.add(Dense(units=32, activation='relu'))
    dnn.add(Dropout(0.5))
    dnn.add(Dense(units=32, activation='relu'))
    dnn.add(Dense(units=2, activation='sigmoid'))  # Adjust the number of units
    dnn.compile(optimizer='Adam', loss='categorical_crossentropy', metrics=['accuracy'])

    # Model training
    if not os.path.exists("model/dnn_weights.h5"):
        model_checkpoint = ModelCheckpoint(filepath='model/dnn_weights.h5', verbose=1, save_best_only=True)
        hist = dnn.fit(x_train, y_train_encoded, batch_size=8, epochs=16, validation_data=(x_test, y_test_encoded), callbacks=[model_checkpoint], verbose=1)

        predictions = dnn.predict(x_test)
        predicted_labels = np.argmax(predictions, axis=1)
        true_labels = np.argmax(y_test_encoded, axis=1)

        print("Confusion Matrix of DNN Model:")
        print(confusion_matrix(true_labels, predicted_labels))

        print("\nClassification Report of DNN Model:")
        print(classification_report(true_labels, predicted_labels))
    else:
        dnn.load_weights("model/dnn_weights.h5") 
    predictions = dnn.predict(x_test)
    predicted_labels = np.argmax(predictions, axis=1)
    true_labels = np.argmax(y_test_encoded, axis=1)

    #test_loss, test_accuracy = dnn.evaluate(x_test, y_test)
    #print(f'DNN Model Test Accuracy: {test_accuracy * 100:.2f}%')

    
    p3 = precision_score(true_labels, predicted_labels, average='macro', zero_division=0) * 100
    r3= recall_score(true_labels, predicted_labels, average='macro', zero_division=0) * 100
    f3 = f1_score(true_labels, predicted_labels, average='macro', zero_division=0) * 100
    a3 = accuracy_score(true_labels, predicted_labels) * 100
    
    accuracy.append(a3)
    precision.append(p3)
    recall.append(r3)
    fscore.append(f3)
    
    text.insert(END, "DNN Precision: " + str(p3) + "\n")
    text.insert(END, "DNN Recall: " + str(r3) + "\n")
    text.insert(END, "DNN FMeasure: " + str(f3) + "\n")
    text.insert(END, "DNN Accuracy: " + str(a3) + "\n\n")
    cm = confusion_matrix(true_labels, predicted_labels)
    cr = classification_report(true_labels, predicted_labels)
    text.insert(END, "Confusion Matrix of DNN Mode:\n")
    text.insert(END, str(cm) + "\n\n")
    text.insert(END, "Classification Report of DNN Mode:\n")
    text.insert(END, cr)
    rocGraph(true_labels, predicted_labels, "DNN")
    plt.figure(figsize=(8, 6))
    sns.set(font_scale=1.2)  # Adjust font size for better visualization
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Anomaly Detected', 'NO Anomaly Detected'], yticklabels=['Anomaly Detected', 'NO Anomaly Detected'])
    plt.xlabel('Predicted label')
    plt.ylabel('True label')
    plt.title('DNN Confusion Matrix')
    plt.show()
  


malware_classes = ['s','b']

def Predict():
    filename = filedialog.askopenfilename(initialdir="Dataset")
    dataset = pd.read_csv(filename)
    text.delete('1.0', END)
    label_encoder = LabelEncoder()
    dataset=dataset.values
    prediction=rf.predict(dataset)
    #predicted_labels = np.argmax(prediction, axis=1)

    for i in range(len(prediction)):
        
        if prediction[i] == 0:
            text.insert(END,"Data : "+str(dataset[i])+" ====> Anomaly Detected \n\n")
        else:
            text.insert(END,"Data : "+str(dataset[i])+" ====> NO Anomaly Detected'\n\n")
         
def graph():
    # Create a DataFrame
    df = pd.DataFrame([
    ['DTC', 'Precision', precision[1]],
    ['DTC', 'Recall', recall[1]],
    ['DTC', 'F1 Score', fscore[1]],
    ['DTC', 'Accuracy', accuracy[1]],
    ['RFC', 'Precision', precision[0]],
    ['RFC', 'Recall', recall[0]],
    ['RFC', 'F1 Score', fscore[0]],
    ['RFC', 'Accuracy', accuracy[0]],
    ['DNN', 'Precision', precision[2]],
    ['DNN', 'Recall', recall[2]],
    ['DNN', 'F1 Score', fscore[2]],
    ['DNN', 'Accuracy', accuracy[2]],
    ], columns=['Parameters', 'Algorithms', 'Value'])
    

    # Pivot the DataFrame and plot the graph
    pivot_df = df.pivot_table(index='Parameters', columns='Algorithms', values='Value', aggfunc='first')
    pivot_df.plot(kind='bar')
    # Set graph properties
    plt.title('Classifier Performance Comparison')
    plt.ylabel('Score')
    plt.xticks(rotation=0)
    plt.tight_layout()
    # Display the graph
    plt.show()
def close():
    main.destroy()

font = ('times', 16, 'bold')
title = Label(main, text='An Innovative and Intelligent Malware Prediction with Classification for Industrial IoT Systems', justify=LEFT)
title.config( fg='black')  
title.config(font=font)           
title.config(height=3, width=120)       
title.place(x=100,y=5)
title.pack()

font1 = ('times', 13, 'bold')
uploadButton = Button(main, text="Upload Dataset", command=uploadDataset)
uploadButton.place(x=200,y=100)
uploadButton.config(font=font1)

preprocessButton = Button(main, text="Preprocess Dataset", command=preprocessDataset)
preprocessButton.place(x=500,y=100)
preprocessButton.config(font=font1)

knnButton = Button(main, text="DecisionTree classifier", command=decisiontreeclassifier)
knnButton.place(x=500,y=150)
knnButton.config(font=font1)

LRButton = Button(main, text="Randomforestclassifier", command=Randomforestclassifier)
LRButton.place(x=200,y=150)
LRButton.config(font=font1)

dnnButton = Button(main, text="DNN model", command=trainDNN)
dnnButton.place(x=700,y=150)
dnnButton.config(font=font1)

predictButton = Button(main, text="Prediction", command=Predict)
predictButton.place(x=500,y=200)
predictButton.config(font=font1)

graphButton = Button(main, text="Comparison Graph", command=graph)
graphButton.place(x=200,y=200)
graphButton.config(font=font1)

exitButton = Button(main, text="Exit", command=close)
exitButton.place(x=500,y=250)
exitButton.config(font=font1)

                            

font1 = ('times', 12, 'bold')
text=Text(main,height=20,width=120)
scroll=Scrollbar(text)
text.configure(yscrollcommand=scroll.set)
text.place(x=10,y=300)
text.config(font=font1) 

main.config(bg='lavender')
main.mainloop()
